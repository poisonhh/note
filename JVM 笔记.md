## Java内存区域

### 运行时数据区域

- 虚拟机栈
- 本地方法栈
- 程序计数器
- 方法区
- 堆

### 四种引用类型
| 引用类型 | 用途           | 被回收时间 | 生存时间          |
| -------- | -------------- | ---------- | ----------------- |
| 强引用   | 对象的一般状态 | 从来不会   | JVM停止运行时终止 |
| 软引用   | 对象缓存       | 内存不足   | 内存不足时终止    |
| 弱引用   | 对象缓存       | 垃圾回收   | GC运行后终止      |
| 虚引用   | unknow         | unknow     | unknow            |

强引用 > 软引用 > 弱引用 > 虚引用

## 垃圾收集器与内存分配策略

### 判断对象是否存活
- 引用计数法(解决不了循环引用的问题)
- 可达性分析算法
    - 基本思想：通过一系列称为"GC Root"的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链(Reference Chain)，当一个对象到GC Roots没有任何引用链相连(GC Roots 不可达时)，则证明此对象是不可用的。
    - 可作为GC Roots的对象包括:
        - 虚拟机栈(栈帧中的本地变量表)中引用的对象
        - 方法区中类静态属性引用的对象
        - 方法区中常量引用的对象
        - 本地方法栈中JNI(即一般说的Native方法)引用的对象
        - 活跃线程的引用对象

### 对象的回收
一个对象真正被回收至少要经历两次标记过程：如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。

==**当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都视为"没必要执行"。**==

如果这个对象被判定为有必要执行finalize()方法，那么这个对象会放置在一个叫做F-Queue的队列之中，并在稍后由一个虚拟机自动建立的、低优先级的Finalizer线程去执行它。finalize()方法是对象逃脱死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果对象要在finalize()中成功拯救自己(只要重新与引用链上的任何一个对象建立关联即可)；如果对象这时候还没有逃脱，那基本上它就真的被回收了。

==**任何一个对象的finalizeI()方法都只会被系统自动调用一次，如果对象面临下一次回收，它的finalize()方法不会被再次执行**==

#### 回收方法区
永久代的垃圾收集主要回收两部分内容
- 废弃常量
    - 当前系统没有其他地方引用了这个字面量
- 无用的类
    - 该类所有的实例都已经被回收
    - 加载该类的ClassLoader已经被回收
    - 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

### 垃圾收集算法

##### 标记-清除算法
- 标记和清除两个阶段
    首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。
- 不足
    - 效率问题，标记和清除两个过程效率都不高
    - 空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动。

##### 复制算法
为了解决效率问题，复制算法将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另一块内存上面，然后把已使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。

##### 标记-整理算法
让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存

解决了标记-清除空间碎片问题

##### 分代收集算法
将内存分为新生代和老年代
- 新生代：复制算法
- 老年代：标记-清理或者标记-整理 算法

### HotSpot算法实现

##### 枚举根节点
准确式GC：在HotSpot实现中，使用一组称为OopMap的数据结构，在类加载完成的时候，HotSpot就把对象内什么偏移量上是什么类型的数据计算出来，在JIT编译过程中，也会在特定的位置记录下栈和寄存器中哪些位置是引用。
##### 安全点(Safepoint)
让GC发生时让所有线程都跑到最近的安全点上再停顿下来。
- 抢先式中断：不需要线程的执行代码主动配合，在GC发生时，首先把所有线程全部中断，如果发现有线程中断的地方不在安全点上，就恢复线程，让它跑到安全点上。(几乎没有虚拟机实现采用这种方式)
- 主动式中断：不直接对线程操作，仅仅简单的设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起。

轮询标志的地方和安全点是重合的，另外再加上创建对象需要分配内存的地方。
##### 安全区域(Safe Region)
安全区域是指在一段代码片段之中，引用关系不会发生变化。在这个区域中的任意地方开始GC都是安全的。在线程执行到Safe Region中的代码时，首先标识自己已经进入了Safe Region，当在这段时间里JVM要发起GC时，就不用管标识自己为Safe Region状态的线程了。在线程要离开Safe Region时，它要检查系统是否已经完成了根节点枚举(或者是整个GC过程)如果完成了，那线程就继续执行，否则它就必须等待直到收到可以安全离开Safe Region的信号为止。

### 垃圾收集器

##### Serial收集器
单线程收集器，它只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。"Stop The World"

##### ParNew收集器
Serial收集器的多线程版本

运行在Server模式下的虚拟机中首选的新生代收集器，目前只有它能与CMS收集器配合工作。

##### Parallel Scavenge收集器
新生代收集器，它也是使用复制算法的收集器，又是并行的多线程收集器。
目标：达到一个可控制的吞吐量(Throughput)

吞吐量 = 运行用户代码时间 /(运行用户代码时间+垃圾收集时间)

- -XX:MaxGCPauseMillis 控制最大垃圾手机停顿时间(大于0的毫秒数)
- -XX:GCTimeRatio 直接设置吞吐量大小(0~100的整数)
- -XX:UseAdaptiveSizePolicy GC自适应的调节策略

##### Serial Old收集器
Serial收集器的老年代版本，单线程收集器，使用标记-整理算法。

主要意义给Client模式下的虚拟机使用

##### Parallel Old收集器
Parallel Scavenge收集器的老年代版本，使用多线程的标记-整理算法。

##### CMS(Concurrent Mark Sweep)收集器
以获取最短回收停顿时间为目的的收集器。采用标记-清除算法实现。

**运作过程**

- 初始标记(CMS initial mark)：标记GC Roots能直接关联到的对象，速度很快。
- 并发标记(CMS concurrent mark)：GC RootsTracing
- 重新标记(CMS remark)：修正并发标记期间因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录(初始<停顿时间<并发)
- 并发清除(CMS concurrent sweep)

初始标记、重新标记两个阶段需要"Stop The World"

并发标记、并发清除耗时最长，但都可以与用户线程一起工作

缺点
- 对CPU资源非常敏感
- 无法处理浮动垃圾(Floating Garbage)
- 造成大量的空间碎片(标记-清除算法)
    - -XX:+UseCMSCompactAtFullCollection : 用于在CMS收集器顶不住要进行FullGC时开启内存碎片的合并整理过程，内存整理的过程是无法并发的，空间碎片问题没有了，但是停顿时间变长了。
    - -XX:CMSFullGCsBeforeCompaction：这个参数是用于设置执行多少次不压缩的Full GC后，跟着来一次带压缩的(默认值为0，表示每次进入Full GC时都进行碎片整理)

##### G1收集器
- 并行与并发
- 分代收集
- 空间整合：整体上看是基于"标记-整理"算法实现，局部(两个Region之间)基于复制算法实现，长时间运行不会产生空间碎片。
- 可预测的停顿：让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，实时垃圾收集的特征。
  它将整个Java堆划分为多个大小相等的独立区域(Region)，虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region(不需要连续)的集合。

之所以能建立可预测的停顿时间模型，是因为它可以有计划地避免在整个Java堆中进行全区域的垃圾收集。G1跟踪各个Region里面的垃圾堆积的价值大小(回收所获得的空间大小以及回收所需时间的经验值)，在后台维护一个优先列表，每次根据允许的收集时间，
优先回收价值最大的Region(这也就是Garbage-First名称的来由)，这种使用Region划分内存空间以及有优先级的区域回收方式，保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。

Remembered Set ：避免全堆扫描

运作过程
- 初始标记(Initial Marking)
- 并发标记(Concurrent Marking)
- 最终标记(Final Marking)
- 筛选回收(Live Data Counting and Evacuation)

### 内存分配与回收策略

大多数情况下，对象在新生代Eden区中分配，当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。
- 新生代GC(Minor GC)
- 老年代GC(Major GC/Full GC)

#### 大对象直接进入老年代

大对象：需要大量连续内存空间的Java对象

-XX:PretenureSizeThreshold : 令大于这个设置值的对象直接在老年代分配，避免在Eden区及两个Survivor区之间发生大量的内存复制。

#### 长期存活的对象将进入老年代

虚拟机给每个对象定义了一个对象年龄(Age)计数器。

如果对象在Eden出生并经过第一次Minor。

 GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并且对象年龄设为1。

对象在Survivor中每熬过一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度(默认为15岁)，就将会被晋升到老年代。

对象晋升老年代的年龄阈值设置  -XX:MaxTenuringThreshold设置

#### 动态年龄判断

如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于改年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。

#### 空间分配担保

在发生Minor GC之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC可以确保
是安全的。如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小

如果大于，将尝试着进行一次Minor GC，尽管这次Minor GC是有风险的；

如果小于，或者HandlePromotionFailure设置不允许冒险，那这时也要改为进行一次Full GC。

## 虚拟机性能监控与故障处理工具

### JDK监控和故障处理工具

- jps：虚拟机进程状况工具
- jstat：虚拟机统计信息监视工具
- jinfo：Java配置信息工具
- jmap：Java内存映像工具
- jhat：虚拟机堆转储快照分析工具
- jstack：Java堆栈跟踪工具

## 虚拟机类的加载机制

### 类的加载过程

加载-验证-准备-解析-初始化-使用-卸载

- 加载
    - 通过一个类的全限定名来获取定义此类的二进制字节流
        - zip 
        - 从网络中获取，Applet
        - 运行时计算生成 (动态代理技术)
        - 其他文件生成，JSP
        - 从数据库中读取

    - 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
    - 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口
- 验证
    - 文件格式验证

        该验证阶段的主要目的是保证输入的字节流能正确的解析并存储于方法区之内，只有通过了这个阶段的验证之后，字节流才会进入内存的方法区中进行存储，后面的验证阶段全部都是基于方法区的存储结构进行的，不会在直接操作字节流。
    - 元数据验证

        该阶段的主要目的是对类的元数据信息进行语义校验，保证不存在不符合Java语言规范的元数据信息。
    - 字节码验证
    - 符号引用验证
- 解析

    解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。

    - 符号引用

        符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义的定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中。

    - 直接引用

        直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局相关的，用一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在内存中存在。

    解析动作的主要针对对象
    - 类/接口 (CONSTANT_Class_info)
    - 字段 (CONSTANT_Fieldref_info)
    - 类方法 (CONSTANT_Methodref_info)
    - 接口方法 (CONSTANT_InterfaceMethodref_info)
    - 方法类型 (CONSTANT_MethodType_info)
    - 方法句柄 (CONSTANT_MethodHandle_info)
    - 调用点限定符 (CONSTANT_InvokeDynamic_info)

- 准备

    准备阶段是正式为变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。

### 双亲委派模型

- 启动类加载器(Bootstrap ClassLoader)
- 扩展类加载器(Extension ClassLoader)
- 应用程序类加载器(Application ClassLoader)

工作过程：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委托给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父类加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。