# MySQL知识点

## 通用模块

### 逻辑架构

1. 连接层：主要完成一些类似于连接处理，授权认证相关的方案；
2. 服务层：主要完成大多数核心服务功能；
3. 引擎层：负责MySQL中数据的存储和提取，服务器通过API与存储引擎进行通信；
4. 存储层：数据存储层，主要是将数据存储在运行于裸设备的文件系统之上，并完成与存储引擎的交互；

### 查询内部执行过程

客户端->服务器->连接器->分析器->优化器->执行器

1. 客户端通过连接器连接到MySQL服务器
2. 连接器权限验证通过之后，向查询是否有缓存，如果有缓存（之前执行过该条语句）则返回缓存数据，如果不存在缓存数据则进入分析器
3. 分析器会对查询语句进行语法分析和词法分析，以判断sql语法是否正确，如果查询语句语法错误直接返回客户端错误信息，如果正确则进入优化器
4. 优化器会对查询语句进行优化处理，比如一个表种存在多个索引，优化器会比较判别哪个索引性能更好
5. 优化器执行完成就进入执行器，执行器就开始执行查询语句进行查询对比了，知道查询到满足条件的所有数据，然后返回数据

### 查询缓存

很多数据库产品都能够缓存查询的执行计划，对于相同类型的SQL就可以跳过SQL解析和执行计划生成截断。MySQL在某些场景下也可以实现，但是MySQL还有另一种不同的缓存类型：缓存完整的select查询结果，也就是查询缓存。

MySQL查询缓存保存查询返回的完整结果。当查询命中该缓存，MySQL会like返回结果，跳过了解析、优化和执行截断。

查询缓存系统会跟踪查询中涉及的每个表，如果这些表发生变化，那么和这个表相关的所有的缓存数据都将失效。这种机制效率看起来比较低，因为数据表变化时很有可能对应的查询结果没有变更，但是这种简单实现代价很小，而这点对于一个非常繁忙的系统来说非常重要。

查询缓存对应用程序是完全透明的。应用程序无需关心MySQL是通过查询返回的还是实际执行返回的结果。事实上，这两种方式执行的结果是完全相同的。换句话说，查询缓存无需使用任何语法。无论是MySQL开启或关闭查询缓存，对程序都是透明的。

随着现在的通用服务器越来越强大，查询缓存被发现是一个影响服务器扩展性的因素。它可能成为整个服务器的资源竞争单点，在多核服务器上还可能导致服务器僵死。所以大部分时候应该默认关闭查询缓存，如果查询缓存作用很大的话，可以配置个几十兆的小缓存空间。

### 表空间

### 表收缩

### 前置索引

<https://www.jianshu.com/p/85a18c1e7d41>

### 回表查询

#### 什么是回表查询？

InnoDB有两大类索引：

- 聚集索引（clustered index）
- 普通索引（secondary index）

InnoDB聚集索引和普通索引的差异

InnoDB聚集索引的叶子节点存储行记录，因此，InnoDB必须要有，且只有一个聚集索引：

1. 如果表定义了PK，则PK就是聚集索引
2. 如果表没有定义PK，则第一个not NULL unique列是聚集索引
3. 否则，InnoDB会创建一个隐藏的row-id作为聚集索引

所以PK查询非常快，直接定位记录

InnoDB普通索引的叶子节点存储主键值。

注意：不是存储行记录头指针，MyISAM的索引叶子节点存储记录指针。

　*t(id PK, name KEY, sex, flag);*

*画外音：id是聚集索引，name是普通索引。*

表中有四条记录：

　　*1, shenjian, m, A*

　　*3, zhangsan, m, A*

　　*5, lisi, m, A*

　　*9, wangwu, f, B*

两个B+树索引分别如上图：

1. id为PK，聚集索引，叶子节点存储行记录；
2. name为KEY，普通索引，叶子节点存储PK值，即id；

既然从普通索引无法直接定位行记录，那**普通索引的查询过程是怎么样的呢？**

通常情况下，需要扫码两遍索引树。

例如：

```java
select * from t where name='lisi';　
```

**是如何执行的呢？**

如**粉红色**路径，需要扫码两遍索引树：

1. 先通过普通索引定位到主键值id=5；
2. 在通过聚集索引定位到行记录；

这就是所谓的**回表查询**，先定位主键值，再定位行记录，它的性能较扫一遍索引树更低。

#### 什么是索引覆盖（Covering index）?

MySQL官网，类似的说法出现在explain查询计划优化章节，即explain的输出结果Extra字段为**Using index**时，能够触发索引覆盖。

不管是SQL-Server官网，还是MySQL官网，都表达了：只需要在一棵索引树上就能获取SQL所需的所有列数据，无需回表，速度更快。

#### 如何实现索引覆盖？

常见的方法是：将被查询的字段，建立到联合索引里去。

```java
create table user (
    id int primary key,
    name varchar(20),
    sex varchar(5),
    index(name)
)engine=innodb;
```

第一个SQL语句：

```java
select id,name from user where name='shenjian';　
```

能够命中name索引，索引叶子节点存储了主键id，通过name的索引树即可获取id和name，无需回表，符合索引覆盖，效率较高。

*画外音，Extra：**Using index**。*

第二个SQL语句：

```java
select id,name,sex from user where name='shenjian';
```

能够命中name索引，索引叶子节点存储了主键id，但sex字段必须回表查询才能获取到，不符合索引覆盖，需要再次通过id值扫码聚集索引获取sex字段，效率会降低。

*画外音，Extra：**Using index condition**。*

如果把(name)单列索引升级为联合索引(name, sex)就不同了。

```java
create table user (
    id int primary key,
    name varchar(20),
    sex varchar(5),
    index(name, sex)
)engine=innodb;
```

可以看到：

```java
select id,name ... where name='shenjian';
 
select id,name,sex ... where name='shenjian';
```

都能够命中索引覆盖，无需回表。

*画外音，Extra：**Using index**。*

#### 哪些场景可以利用索引覆盖来优化SQL?

1. 场景1：全表count查询优化

   原表为：

   *user(PK id, name, sex)；*

   直接：

   ```java
   select count(name) from user;
   ```

   不能利用索引覆盖。

   添加索引：

   ```java
   alter table user add key(name);
   ```

   就能够利用索引覆盖提效。

2. 场景2：列查询优化

   ```java
   select id,name,sex ... where name='shenjian';
   ```

   这个例子不再赘述，将单列索引(name)升级为联合索引(name, sex)，即可避免回表。

3. 场景3：分页查询

   ```java
   select id,name,sex ... order by name limit 500,100;
   ```

   将单列索引(name)升级为联合索引(name, sex)，也可以避免回表。

### 内存表VS临时表

#### 内存表

##### 简介

内存表的表结构建立在磁盘里面，数据放在内存里面，当mysql重启之后，内存表的数据会丢失，表结构依旧存在会执行一次truncate操作

##### 内存表的建立

```java
CREATE TABLE tmp_memory (i INT) ENGINE = MEMORY;
```

##### 查看表结构：

```java
show tables;
show table status;
```

这两个命令无法查看临时表。 但是可以查内存表

##### 使用场景及注意事项

内存表使用hash索引把数据保存在内存中，具有更快的速度，可以用来缓存。

- 内存表对所有的用户连接都是可用的。这就意味着，多个会话连接的内存表名字不能重复，具有唯一性
- 内存表如果复制数据进去的话，所有的原有格式都不会存在，需要重新设置
- 重启造成数据丢失，可以drop表之后重新复制数据等。这是最傻瓜的方法了。
- 支持简单的操作符>=<这三个，我认为内存表用来缓存的话，应该不会涉及很复杂的操作。
- 不好的地方的话，应该在于数据了，因为数据都在内存里，处理起来应该蛮麻烦
- 内存表的默认引擎是memory

##### 特点

1. *多个session，创建表的名字不能一样*
2. *一个session创建会话后，对其他session也是可见的*
3. *data目录下只有tmp_memory.frm ,表结构放在磁盘上，数据放在内存中*
4. *mysql 重启或者关闭后内存表里的数据会丢失，但是表结构仍然存在*
5. *可以创建索引,删除索引,支持唯一索引*
6. *不影响主备，主库上插入的数据，备库也可以查到*
7. *show tables 看得到表*

#### 临时表

##### 简介

临时表是建立在系统临时文件夹中的表。临时表的数据和表结构都存储在内存之中，退出的时候所占的空间会被释放。

##### 创建临时表：

```java
CREATE TEMPORARY TABLE tmp_table( 
name VARCHAR(10) NOT NULL, 
value INT NOT NULL 
);
```

关键字为 TEMPORARY

可以查看表建立sql语句

```java
show create table tmp_table;
```

直接将查询结构导入临时表

```java
create temporary table tmp_table select * from table_name;
```

##### 设置临时表大小

tmp_table_size 临时表的容量

##### 使用场景及注意事项

- 临时表只在当前连接可见，当这个连接关闭的时候，会自动drop。比如打开mysql 就是一个连接会话。两个不同的连接可以使用相同名字的临时表，两个表之间不存在什么关系，如果临时表的名字和已经存在的磁盘表名字一样，那么临时表会暂时覆盖磁盘表。就是说，你select 查询，只会显示临时表里面的，不会显示磁盘表
- 临时表的存储引擎：Memory，MyISAM，Merge，InnoDB
- 临时表不支持，mysql cluster
- 同一个查询语句，只能用一次临时表，就是说不能将表和自己做连接等
- 重命名表，不能用rename 可以用alter table代替
- 如果超出了临时表的容量，临时表会转换成磁盘表

##### 特点

1. 创建的表的名字可以一样 
2. 表结构和数据都放在内存中
3. 会话消失表结构和数据都消失
4. 可以创建索引,删除索引
5. 主库创建的表，备库查不到
6. show tables 看不到表

#### 总结

对比一下内存表和临时表的一些主要区别吧

- 存储
  - 内存表 表结构存储在磁盘中，数据存储在内存中
  - 临时表 表结构和数据都存储在内存中
- 会话
  - 内存表 是可以多个会话共享的
  - 临时表 是单个会话独享的，是会话级别的
- 引擎
  - 内存表默认，Memory
  - 临时表默认，MyISAM（可以为任意存储引擎）
- 断开连接
  - 临时表 啥都不剩
  - 内存表 只剩下表结构（data目录下 tableName.frm）
- 性能
  - 内存表由于所有的内容都是放在内存中，所以相对来说，速度较快但是同时数据的维护较为困难

### 数据类型间的区别

### 删除表的几种方式和性能对比

### 枚举

### count(1)/count(*)/count(字段)性能对比

count(column)<count(pk)<count(1)≈count(*)

> 1、COUNT有几种用法？
>
> 2、COUNT(字段名)和COUNT(*)的查询结果有什么不同？
>
> 3、COUNT(1)和COUNT(*)之间有什么不同？
>
> 4、COUNT(1)和COUNT(*)之间的效率哪个更高？
>
> 5、为什么《阿里巴巴Java开发手册》建议使用COUNT(*)
>
> 6、MySQL的MyISAM引擎对COUNT(*)做了哪些优化？
>
> 7、MySQL的InnoDB引擎对COUNT(*)做了哪些优化？
>
> 8、上面提到的MySQL对COUNT(*)做的优化，有一个关键的前提是什么？
>
> 9、SELECT COUNT(*) 的时候，加不加where条件有差别吗？
>
> 10、COUNT(*)、COUNT(1)和COUNT(字段名)的执行过程是怎样的？

#### 执行效果

count(*)包括了所有的列，相当于行数，在统计结果的时候，不会忽略列值为NULL

count(1)包括了忽略所有列，用1代表代码行，在统计结果的时候，不会忽略列值为NULL

count(列名)只包括列名那一列，在统计结果的时候，会忽略列值为空(这里的空不是指空字符串或者0，而是表示null)的计数，即某个字段值为NULL时，不统计。

#### count(常量)、count(*)、count(列)使用场景

- 如果要求统计的是表的结果集，使用count(1)或count(*)

- 如果统计的是列值，使用count(列)，count(列)不统计值为NULL的数据

- 当查询count(主键)时，语义count(*)、count(1)一样，但是性能存在差异，count(主键)性能最差，其他两个的性能差异跟数据库引擎有关

  可使用以下脚本查看性能对比：

  ```java
  set profiling = 1;
  SELECT SQL_NO_CACHE count(*) from t_pay_process_record;
  SELECT SQL_NO_CACHE count(1) from t_pay_process_record;
  SELECT SQL_NO_CACHE count(process_record_id) from t_pay_process_record;
  show profiles;
  ```


#### count(*)的优化

count(*)是SQL92定义的标准统计行数的语法，所以MySQL数据库对他进行过很多优化

MyISAM和InnoDB有很多区别，其中有一个关键的区别和我们接下来要介绍的 COUNT(*) 有关，那就是 MyISAM不支持事务，MyISAM中的锁是表级锁； 而InnoDB支持事务，并且支持行级锁。

分别从InnoDB和MyISAM存储引擎来看

因为MyISAM的锁是表级锁，所以同一张表上面的操作需要串行进行，所以，MyISAM做了一个简单的优化，那就是它可以把表的总行数单独记录下来，如果从一张表中使用count(*)进行查询的时候，可以直接返回这个记录下来的数值就可以了，当然，前提是不能有where条件。

MyISAM之所以可以把表中的总行数记录下来供count(*)查询使用，那是因为MyISAM数据库是表级锁，不会有并发的数据库行数修改，所以查询得到的行数是准确的。

但是，对于InnoDB来说，就不能做这种缓存操作了，因为InnoDB支持事务，其中大部分操作都是行级锁，所以可能表的行数可能会被并发修改，那么缓存记录下来的总行数就不准确了。

但是，InnoDB还是针对count(*)语句做了优化的

在InnoDB中，使用count(*)查询行数的时候，不可避免的要进行扫表了，那么，就可以在扫表过程中下功夫来优化效率了。

**前提是查询语句中不包含where或group by等条件**

我们知道，count(*)的目的只是为了统计总行数，所以，它根本不关心自己查到的具体值，所以，如果能够在扫表的过程中，选择一个成本较低的索引进行的话，那就可以大大节省时间。

InnoDB中索引分为聚簇索引(主键索引)和非聚簇索引(非主键索引)，聚簇索引的叶子节点中保存的是整行记录，而非聚簇索引的叶子节点中保存的是改行记录的主键值。

所以相比之下，非聚簇索引要比聚簇索引小很多，所以MySQL会优先选择最小的非聚簇索引来扫表。所以，当我们建表的时候，除了主键索引以外，创建一个非主键索引还是有必要的。

**至此，我们介绍完了MySQL数据库对于COUNT(*)的优化，这些优化的前提都是查询语句中不包含WHERE以及GROUP BY条件。**

#### count(*)和count(1)

介绍完了 COUNT(*) ，接下来看看 COUNT(1) ，对于，这二者到底有没有区别，网上的说法众说纷纭。

有的说 COUNT(*) 执行时会转换成 COUNT(1) ，所以COUNT(1)少了转换步骤，所以更快。

还有的说，因为MySQL针对 COUNT() 做了特殊优化，所以 COUNT() 更快。

那么，到底哪种说法是对的呢？ 看下MySQL官方文档是怎么说的：

InnoDB handles SELECT COUNT(*) and SELECT COUNT(1) operations in the same way. There is no performance difference.

画重点： same way , no performance difference 。 所以，对于COUNT(1)和COUNT(*)，MySQL的优化是完全一样的，根本不存在谁比谁快！

那既然 COUNT(*) 和 COUNT(1) 一样，建议用哪个呢？

建议使用 COUNT(*) ！ 因为这个是SQL92定义的标准统计行数的语法，而且本文只是基于MySQL做了分析，关于Oracle中的这个问题，也是众说纷纭的呢。

### 视图

### 删除数据恢复和原理分析

### 数据库引擎

#### InnoDB

#### MyISAM

### 数据结构

## 索引

### 模糊查询与索引

### 唯一索引和普通索引的性能对比

### 全局索引

### 聚集索引VS非聚集索引

### 最左匹配原则

### 前缀索引

### 存储算法

### 优化器如何选择索引

#### 概念

- 在索引建立之后，一条语句可能会命中多个索引，这时，索引的选择就会交由优化器来选择合适的索引
- 优化器选择索引的目的，是找到一个最优的执行方案，并用最小的代价去执行语句

#### 优化器选择索引的原则

- 在数据库里面，扫描行数是影响执行代价的因素之一
- 扫描的行数越少，意味着访问磁盘数据的次数越少，消耗的CPU资源越少
- 当然，扫描行数并不是唯一的判断标准，优化器还会结合是否使用临时表、是否排序等因素进行综合判断

#### 优化器是如何判断扫描行数的

- MySQL在真正开始执行语句之前，并不能精确的知道满足这个条件的记录有多少条，而只能根据统计信息来估算记录数
- 这个统计信息就是索引的“区分度”
  - 显然，一个索引上不同的值越多，这个索引的区分度就越好
  - 而一个索引上不同的值的个数，我们称之为“基数“(cardinality)
  - 也就是说，这个基数越大，索引的区分度越好
  - 可以使用show index方法，看到一个索引的基数
- 在使用普通索引，因为都要回表到主键索引上查出整行数据，这个代价优化器也要算进去的

#### MySQL是怎样得到统计信息的呢

- 使用采样统计
- 原理
  - 采样统计的时候，InnoDB默认会选择N个数据页，统计这些页上的不同值，得到一个平均值，然后乘以这个索引的页面数，就得到了这个索引的基数
  - 而数据表是会持续更新的，索引统计信息也不会固定不变。所以，当变更的数据行超过1/M的时候，会自动触发重新做一次索引统计。
- 为什么需要使用采样统计
  - 因为把整张表取出来一行行统计，虽然可以得到精确的结果，但是代价太高了，所以只能选择”采样统计“
- 在MySQL中，有两种存储索引统计的方式，可以通过设置参数innodb_stats_persistent的值来选择
  - 设置为on的时候，表示统计信息会持久化存储。这时，默认的N是20，M是10。
  - 设置为off的时候，表示统计信息只存储在内存中。这时，默认的N是8，M是16。
  - 由于是采用统计，所以不管N是20还是8，这个基数都是很容易不准的。

#### 索引选择异常的问题可以有哪几种处理方式

- 重新统计索引信息
  - 既然是统计信息不对，那就修正。analyze table t命令，可以用来重新统计索引信息。
- 指定使用索引
  - select * from table force index('index_name');

### 不使用索引的原因列举

1. 使用不等于查询
2. 列参与了数学运算或者函数
3. 在字符串like时左边是通配符，类似于'%aaa'
4. 当mysql分析全表扫描比使用索引快的时候不使用索引
5. 当使用联合索引，前面一个条件为范围查询，后面的即使符合最左前缀原则，也无法使用索引

## 高性能

### 慢查询排查

### 读写分离

### 主备无延迟

### 多实例配置

### 水平分区

### 性能分析

## 锁

### 死锁和案例

### 全局锁

### 表锁

### 行锁

### 乐观锁/悲观锁

### 排它锁

### 锁优化

## 事务

### 事务特性

### 脏读

### 幻读

### 不可重复读

### 事务隔离

### 并发事务

### 事务实现原理

## 日志

### 错误日志

在MySQL数据库中，错误日志功能是默认开启的，而且无法被关闭。默认情况，错误日志存储在mysql数据库的数据文件中。错误日志文件通常的名称为hostname.err（hostname表示服务器的主机名）。

错误日志会记录如下信息

- mysql执行过程中的错误信息
- mysql执行过程中的告警信息
- event scheduler 运行时所产生信息
- mysql启动和停止过程中产生的信息
- 主从复制结构中，从从服务器IO复杂线程的启动信息

错误日志相关参数

- log_error：错误日志的存放路径
- log_warnings：表示是否记录告警信息到错误日志，0表示不记录告警信息，1表示记录告警信息，大于1表示各类告警信息，例如有关网络故障的信息和重新连接信息写入错误日志

### 查询日志

查询自然在mysql中被称之为general log，查询日志记录了数据库执行的命令，不管这些语法是否正确，都会被记录。由于数据库操作命令非常多而且比较频繁，所以开启了查询日志以后，数据库可能需要不停的写入查询，这样会增大服务器的IO压力，增加很多的系统开销，所以默认情况下，mysql的查询日志是没有开启的，但是开启查询日志也有助于我们分析那些语句执行密集，执行密集的select语句对应的数据是否能够被缓存，查询日志也可以帮助我们分析问题，所以，我们可以更具实际情况决定是否开启查询日志，如果需要可以手动开启。

查询日志相关参数

- general_log：表示查询日志是否开启，ON表示开启，OFF表示未开启，默认OFF
- log_output：表示查询日志开启以后，以哪种方式存放于文件中，**TABLE**表示存放于表mysql.general_log中(慢查询存放于mysql.slow_log)，**FILE,TABLE**表示同时存放于文件和表中，**NONE**表示不记录日志。log_output不仅控制查询日志，还控制慢查询日志。
- general_log_file：表示查询日志存放于文件的路径

### 慢日志

某些sql语句执行完毕所花费的时间特别长，我们将这种响应比较慢的语句记录在慢查询日志中，只要超过指定时间的sql语句，都称为“慢查询”，被记录在慢查询日志中。

慢查询日志默认情况下是关闭的，默认设置下，超过10s的语句才会被记录到慢查询日志中。

慢查询日志相关参数

- slow_query_log：表示查询日志是否开启，**ON**表示开启，**OFF**表示未开启，默认**OFF**
- slow_query_log_file：表示查询日志存放于文件的路径
- long_query_time：表示多长时间的查询被认为“慢查询”，默认10s
- log_queries_not_using_indexes：表示如果运行的sql语句没有使用到索引，也被记录到慢查询日志，**OFF**表示不记录，**ON**表示记录，默认**OFF**

### binlog(二进制日志)

二进制日志是一个二进制文件，记录了对MySQL数据库执行更改的所有操作，并且记录了语句发生时间、执行时长、操作数据等其他额外信息，但是他不记录SELECT、SHOW等那些不改变数据库的SQL语句。二进制日志主要用于数据库恢复和主从复制，以及审计操作。

二进制日志相关参数

- log_bin：表示二进制日志是否开启，`ON`表示开启，`OFF`表示未开启，默认`OFF`
- log_bin_basename：二进制日志文件前缀名，二进制日志就记录在该文件中
- max_binlog_size：二进制日志文件的最大大小，超过此大小，二进制文件会自动滚动
- log_bin_index：二进制日志文件索引文件名，用于记录所有的二进制文件
- binlog_format：决定了二进制日志的记录方式，`STATEMENT`以语句的形式记录，`ROW`以数据修改的形式记录，`MIXED`以语句和数据修改混合形式记录
- sql_log_bin：决定是否对二进制日志进行日志记录，`ON`表示执行记录，`OFF`表示不执行记录，默认`OFF`，这个是会话级别变量可以通`SET sql_log_bin = {0|1}`来改变该变量值
- sync_binlog：决定二进制日志写入磁盘时机，如果sync_binlog为0，操作系统来决定什么时候写入磁盘，如果sync_binlog为N（N=1,2,3..），则每N次事务提交后，都立即将内存中的二进制日志写入磁盘，如何选择取决于安全性与性能的权衡

#### 二进制日志的三种记录方式

- **STATEMENT**：记录对数据库做出修改的语句，比如，update A set test='test'，如果使用statement模式，那么这条update语句将被记录到二进制日志中，使用statement模式时，优点是binlog日志量少，IO压力小，性能高，缺点是为了尽可能一致的还原操作，除了记录语句本身外，可能还需要记录一些相关信息，而且，在使用一些特定函数时，并不能保证恢复操作与记录完全一致

- **ROW**：记录对数据库做出的修改的语句所影响到的数据行以及这些行的修改，比如，update A set test = 'test'，如果使用row模式，那么这条update所影响到的行所对应的修改，将会记录在binlog中，使用row模式时，优点是能完还原和复制被日志记录时的操作，缺点是日志量较大，IO压力比较大，性能消耗比较大

- **MIXED**：混合上述两种模式，一般使用statement方式进行记录，如果遇到一些特殊函数使用row方式进行记录，这种记录方式称为mixed

#### 二进制日志进行数据库恢复



### redo log(重做日志)

### undo log(回滚日志)

## 命令和内置函数

### 服务器操作

### 服务运行状态

### 执行统计

### 用户授权

### 库表设置

### 删除的N种方式

## 开放性问题

### 超级大表优化

### 线上操作隐患

### 故障排查

### 主从延迟分析

### 误删防范

### 高性能服务器设计