# MySQL知识点

## 通用模块

### 查询内部执行过程

客户端->服务器->连接器->分析器->优化器->执行器

1. 客户端通过连接器连接到MySQL服务器
2. 连接器权限验证通过之后，向查询是否有缓存，如果有缓存（之前执行过该条语句）则返回缓存数据，如果不存在缓存数据则进入分析器
3. 分析器会对查询语句进行语法分析和词法分析，以判断sql语法是否正确，如果查询语句语法错误直接返回客户端错误信息，如果正确则进入优化器
4. 优化器会对查询语句进行优化处理，比如一个表种存在多个索引，优化器会比较判别哪个索引性能更好
5. 优化器执行完成就进入执行器，执行器就开始执行查询语句进行查询对比了，知道查询到满足条件的所有数据，然后返回数据

### 查询缓存

很多数据库产品都能够缓存查询的执行计划，对于相同类型的SQL就可以跳过SQL解析和执行计划生成截断。MySQL在某些场景下也可以实现，但是MySQL还有另一种不同的缓存类型：缓存完整的select查询结果，也就是查询缓存。

MySQL查询缓存保存查询返回的完整结果。当查询命中该缓存，MySQL会like返回结果，跳过了解析、优化和执行截断。

查询缓存系统会跟踪查询中涉及的每个表，如果这些表发生变化，那么和这个表相关的所有的缓存数据都将失效。这种机制效率看起来比较低，因为数据表变化时很有可能对应的查询结果没有变更，但是这种简单实现代价很小，而这点对于一个非常繁忙的系统来说非常重要。

查询缓存对应用程序是完全透明的。应用程序无需关心MySQL是通过查询返回的还是实际执行返回的结果。事实上，这两种方式执行的结果是完全相同的。换句话说，查询缓存无需使用任何语法。无论是MySQL开启或关闭查询缓存，对程序都是透明的。

随着现在的通用服务器越来越强大，查询缓存被发现是一个影响服务器扩展性的因素。它可能成为整个服务器的资源竞争单点，在多核服务器上还可能导致服务器僵死。所以大部分时候应该默认关闭查询缓存，如果查询缓存作用很大的话，可以配置个几十兆的小缓存空间。

### 表空间

### 表收缩

### 前置索引

### 回表查询

### 内存表VS临时表

### 数据类型间的区别

### 删除表的几种方式和性能对比

### 枚举

### count(1)/count(*)/count(字段)性能对比

### 试图

### 删除数据恢复和原理分析

### 数据库引擎

#### InnoDB

#### MyISAM

### 数据结构

## 索引

### 模糊查询与索引

### 唯一索引和普通索引的性能对比

### 全局索引

### 聚集索引VS非聚集索引

### 最左匹配原则

### 前缀索引

### 存储算法

### 优化器如何选择索引

### 不使用索引的原因列举

## 高性能

### 慢查询排查

### 读写分离

### 主备无延迟

### 多实例配置

### 水平分区

### 性能分析

## 锁

### 死锁和案例

### 全局锁

### 表锁

### 行锁

### 乐观锁/悲观锁

### 排它锁

### 锁优化

## 事务

### 事务特性

### 脏读

### 幻读

### 不可重复读

### 事务隔离

### 并发事务

### 事务实现原理

## 日志

### 错误日志

### 查询日志

### 慢日志

### redo log(重做日志)

### binlog(归档日志)

### undo log(回滚日志)

## 命令和内置函数

### 服务器操作

### 服务运行状态

### 执行统计

### 用户授权

### 库表设置

### 删除的N种方式

## 开放性问题

### 超级大表优化

### 线上操作隐患

### 故障排查

### 主从延迟分析

### 误删防范

### 高性能服务器设计