# 分布式唯一ID的几种生成方案

## 需求

在业务开发中，大量场景需要唯一ID来进行标识：用户需要唯一身份标识、商品需要唯一标识、消息需要唯一标识、事件需要唯一标识等，都需要全局唯一ID，尤其是复杂的分布式业务场景中全局唯一ID更为重要。

## 分布式唯一ID的特性或要求

- 唯一性：生成的ID全局唯一，在特定范围冲突概率极小。
- 有序性：生成的ID按某种规则有序，便于数据库插入及排序。
- 可用性：可保证高并发下的可用性，确保任何时候都能正确的生成ID。
- 自主性：分布式环境下不依赖中心认证即可自行生成ID。
- 安全性：不暴露系统和业务的信息。如订单数，用户数等。

## 分布式唯一ID的生成方案

### UUID生成

核心思想：结合机器的网卡(基于名字空间/名字的散列值MD5/SHA1)、当地时间(基于时间戳&时钟序列)、一个随机数来生成UUID。

其结构如下：
aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee（即包含32个16进制数字，以连字号-分为五段，最终形成“8-4-4-4-12”的36个字符的字符串，即32个英数字母+4个连字号）。
例如：550e8400-e29b-41d4-a716-446655440000

优点：

 1. 本地生成，没有网络消耗，生成简单，没有高可用风险。

缺点：

 1. 不易于存储：UUID太长，16字节128位，通常以36长度的字符串表示，很多场景不适用。
 2. 信息不安全：基于MAC地址生成UUID的算法可能造成MAC地址泄露，这个漏洞曾被用于寻找梅丽莎病毒的制作者位置。
 3. 无序查询效率低：由于生成的UUID是无序不可读的字符串，所以其查询效率低。

#### 5种方式生成UUID：

##### 基于时间的UUID

规则：主要依赖当前的时间戳及机器mac地址，因此可以保证全球唯一性。
优点：能基本保证全球唯一性。
缺点：使用了Mac地址，因此会暴露Mac地址和生成时间。

##### 分布式安全的UUID

规则：将版本1的时间戳前四位换为POSIX的UID或GID，很少使用。
优点：能保证全球唯一性。
缺点：很少使用，常用库基本没有实现。

##### 基于名字空间的UUID-MD5版

规则：基于指定的名字空间/名字生成MD5散列值得到，标准不推荐。
优点：不同名字空间或名字下的UUID是唯一的；相同名字空间及名字下得到的UUID保持重复。
缺点：MD5碰撞问题，只用于向后兼容，后续不再使用。

##### 基于随机数的UUID

规则：基于随机数或伪随机数生成。
优点：实现简单。
缺点：重复几率可计算。机率也与随机数产生器的质量有关。若要避免重复机率提高，必须要使用基于密码学上的强伪随机数产生器来生成值才行。

##### 基于名字空间的UUID-SHA1版

规则：将版本3的散列算法改为SHA1。
优点：不同名字空间或名字下的UUID是唯一的；相同名字空间及名字下得到的UUID保持重复。
缺点：SHA1计算相对耗时。

总得来说：

1. 版本 1/2 适用于需要高度唯一性且无需重复的场景。
2. 版本 3/5 适用于一定范围内唯一且需要或可能会重复生成UUID的环境下。
3. 版本 4 适用于对唯一性要求不太严格且追求简单的场景。

### 数据库自增ID

核心思想：使用数据库的id自增策略(如：Mysql的auto_increment)。

优点：

 - 简单，天然有序。

缺点：

 - 并发性不好
 - 数据库写压力大
 - 数据库故障后不可使用
 - 存在数量泄露风险

#### 针对以上缺点的优化方案：

##### 数据库水平拆分，设置不同的初始值和相同的自增步长

核心思想：将数据库进行水平拆分，每个数据库设置不同的初始值和相同的自增步长。

![数据库水平拆分](./pic/数据库水平拆分.png "数据库水平拆分")

缺点：扩容问题，扩容时会出项无ID初始值可分的窘境。

解决方案：

1. 根据扩容考虑决定步长
2. 增加其他位标记区分扩容

##### 批量缓存自增ID

核心思想：如果使用单台机器做ID生成，可以避免固定步长带来的扩容问题。

具体做法：每次批量生成一批ID给不同的机器去慢慢消费，这样数据库的压力也会减小到N分之一，且故障后可坚持一段时间。

缺点：服务器重启、单点故障会造成ID不连续。

##### Redis生成ID

核心思想：Redis的所有命令操作都是单线程的，本省提供想incr和increby这样的自增原子命令，所以能保证生成的ID肯定是唯一有序的。

优点：

 1. 不依赖于数据库，灵活方便，且性能优于数据库。
 2. 数字ID天然排序，对分页或者需要排序的结果很有帮助。

缺点：

 1. 如果系统中没有Redis，还需要引入新的组件，增加系统复杂度。
 2. 需要编码和配置的工作量较大。

优化方案：

考虑到单节点的性能瓶颈，可以使用Redis集群来获取更高的吞吐量，并利用上面的方案

 - 数据库水平拆分，设置不同的初始值和相同的步长
 - 批量缓存自增ID

来配置集群。

PS：比较适合使用Redis来生成每天从0开始的流水号。比如："订单号=日期+当日自增长号"，则可以每天在Redis中生成一个key，使用INCR进行累加。

### snowflake雪花算法

核心思想：把64-bit分别划分为多段，分开来标示机器、时间、某一并发序列等，从而使每台机器及同一机器生成的ID都是互不相同。

PS：这种结构是雪花算法提出者Twitter的分法，但实际上这种算法使用可以很灵活，根据自身业务的并发情况、机器分布、使用年限等，可以自由地重新决定各部分的位数，从而增加或减少某部分的量级。比如：百度的UidGenerator、美团的Leaf等，都是基于雪花算法做一些适合自身业务的变化。

#### 雪花算法的几种不同优化方案：

##### Twitter的snowflake算法

核心思想：采用big(64bit)作为id生成类型，并将所占的64bit划分成多段。

其结构如下：

| 分段  | 作用               | 说明                           |
| ----- | ------------------ | ------------------------------ |
| 1bit  | 保留               |                                |
| 41bit | 时间戳，精确到毫秒 | 可以支持69年的跨度             |
| 5bit  | DatacenterId       | 可以最多支持32个节点           |
| 5bit  | WorkerId           | 可以最多支持32个节点           |
| 12bit | 毫秒内的计数       | 支持每个节点每毫秒产生4069个ID |

说明：

1. 1位标识：由于long基本类型在Java中是带符号的，最高为是符号位，正数是0，负数是1，所以id一般是正数，最高位是0.
2. 41位时间戳(毫秒级)：需要注意的是，41位时间戳不是存储当前时间的时间戳，而是存储时间戳的差值(当前时间戳 - 开始时间戳) 得到的值，这里的开始时间戳，一般是指我们的id生成器开始使用的时间戳，由我们的程序来指定。41位的毫秒时间戳，可以使用69年(即T=（1L << 41）/ （1000 * 60 * 60 * 24 * 365）= 69）。
3. 10位的数据机器位：包括5位数据中心标识Id(datacenterId)、5位机器标识Id(workerId)、最多可以部署1024个节点(即1<<10 = 1024)。超过这个数量，生成的ID就有可能会冲突。
4. 12位序列：毫秒内的计数，12位的计数顺序号支持每个节点每毫秒（同一机器，同一时间截）产生4096个ID序号（即1 << 12 = 4096）。

PS：全部结构标识（1+41+10+12=64）加起来刚好64位，刚好凑成一个Long型。

优点：

1. 整体上按照时间按时间趋势递增，后续插入索引树的时候性能较好。
2. 整个分布式系统内不会产生ID碰撞（由数据中心标识ID、机器标识ID作区分）。
3. 本地生成，且不依赖数据库（或第三方组件），没有网络消耗，所以效率高（每秒能够产生26万ID左右）。

缺点：

1. 由于雪花算法是强依赖于时间的，在分布式环境下，如果发生时钟回拨，很可能会引起ID重复、ID乱序、服务会处于不可用状态等问题。

   解决方案有：

   - 将ID生成交给少量服务器，并关闭时钟同步。
   - 直接报错，交给上层业务处理。
   - 如果回拨时间较短，在耗时要求内，比如5ms，那么等待回拨时长后再进行生成。
   - 如果回拨时间很长，那么无法等待，可以匀出少量位（1~2位）作为回拨位，一旦时钟回拨，将回拨位加1，可得到不一样的ID，2位回拨位允许标记3次时钟回拨，基本够使用。如果超出了，可以再选择抛出异常。

##### **Mongo的ObjectId算法**

核心思想是：使用12字节（24bit）的BSON 类型字符串作为ID，并将所占的24bit 划分成多段。



##### **百度UidGenerator算法**

UidGenerator是百度开源的分布式ID生成器，是基于snowflake算法的实现，看起来感觉还行，但是需要借助数据库，配置起来比较复杂。

##### **美团Leaf算法**

Leaf 是美团开源的分布式ID生成器，能保证全局唯一性、趋势递增、单调递增、信息安全，里面也提到了几种分布式方案的对比，但也需要依赖关系数据库、Zookeeper等中间件。





<https://www.jianshu.com/p/4ba1c5e8c185>



