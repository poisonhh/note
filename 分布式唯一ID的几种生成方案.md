# 分布式唯一ID的几种生成方案

## 需求

在业务开发中，大量场景需要唯一ID来进行标识：用户需要唯一身份标识、商品需要唯一标识、消息需要唯一标识、事件需要唯一标识等，都需要全局唯一ID，尤其是复杂的分布式业务场景中全局唯一ID更为重要。

## 分布式唯一ID的特性或要求

- 唯一性：生成的ID全局唯一，在特定范围冲突概率极小。
- 有序性：生成的ID按某种规则有序，便于数据库插入及排序。
- 可用性：可保证高并发下的可用性，确保任何时候都能正确的生成ID。
- 自主性：分布式环境下不依赖中心认证即可自行生成ID。
- 安全性：不暴露系统和业务的信息。如订单数，用户数等。

## 分布式唯一ID的生成方案

### UUID生成

核心思想：结合机器的网卡(基于名字空间/名字的散列值MD5/SHA1)、当地时间(基于时间戳&时钟序列)、一个随机数来生成UUID。

其结构如下：
aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee（即包含32个16进制数字，以连字号-分为五段，最终形成“8-4-4-4-12”的36个字符的字符串，即32个英数字母+4个连字号）。
例如：550e8400-e29b-41d4-a716-446655440000

优点：

 1. 本地生成，没有网络消耗，生成简单，没有高可用风险。

缺点：

 1. 不易于存储：UUID太长，16字节128位，通常以36长度的字符串表示，很多场景不适用。
 2. 信息不安全：基于MAC地址生成UUID的算法可能造成MAC地址泄露，这个漏洞曾被用于寻找梅丽莎病毒的制作者位置。
 3. 无序查询效率低：由于生成的UUID是无序不可读的字符串，所以其查询效率低。

#### 5种方式生成UUID：

##### 基于时间的UUID

规则：主要依赖当前的时间戳及机器mac地址，因此可以保证全球唯一性。
优点：能基本保证全球唯一性。
缺点：使用了Mac地址，因此会暴露Mac地址和生成时间。

##### 分布式安全的UUID

规则：将版本1的时间戳前四位换为POSIX的UID或GID，很少使用。
优点：能保证全球唯一性。
缺点：很少使用，常用库基本没有实现。

##### 基于名字空间的UUID-MD5版

规则：基于指定的名字空间/名字生成MD5散列值得到，标准不推荐。
优点：不同名字空间或名字下的UUID是唯一的；相同名字空间及名字下得到的UUID保持重复。
缺点：MD5碰撞问题，只用于向后兼容，后续不再使用。

##### 基于随机数的UUID

规则：基于随机数或伪随机数生成。
优点：实现简单。
缺点：重复几率可计算。机率也与随机数产生器的质量有关。若要避免重复机率提高，必须要使用基于密码学上的强伪随机数产生器来生成值才行。

##### 基于名字空间的UUID-SHA1版

规则：将版本3的散列算法改为SHA1。
优点：不同名字空间或名字下的UUID是唯一的；相同名字空间及名字下得到的UUID保持重复。
缺点：SHA1计算相对耗时。

总得来说：

1. 版本 1/2 适用于需要高度唯一性且无需重复的场景。
2. 版本 3/5 适用于一定范围内唯一且需要或可能会重复生成UUID的环境下。
3. 版本 4 适用于对唯一性要求不太严格且追求简单的场景。

### 数据库自增ID

核心思想：使用数据库的id自增策略(如：Mysql的auto_increment)。

优点：

 - 简单，天然有序。

缺点：

 - 并发性不好
 - 数据库写压力大
 - 数据库故障后不可使用
 - 存在数量泄露风险

#### 针对以上缺点的优化方案：

##### 数据库水平拆分，设置不同的初始值和相同的自增步长

核心思想：将数据库进行水平拆分，每个数据库设置不同的初始值和相同的自增步长。

![数据库水平拆分](D:\hhuang\project\note\数据库水平拆分.png)

​											数据库水平拆分

缺点：扩容问题，扩容时会出项无ID初始值可分的窘境。

解决方案：

 	1. 根据扩容考虑决定步长
 	2. 增加其他位标记区分扩容

##### 批量缓存自增ID

核心思想：如果使用单台机器做ID生成，可以避免固定步长带来的扩容问题。

具体做法：每次批量生成一批ID给不同的机器去慢慢消费，这样数据库的压力也会减小到N分之一，且故障后可坚持一段时间。

缺点：服务器重启、单点故障会造成ID不连续。

##### Redis生成ID

核心思想：Redis的所有命令操作都是单线程的，本省提供想incr和increby这样的自增原子命令，所以能保证生成的ID肯定是唯一有序的。

优点：

 1. 不依赖于数据库，灵活方便，且性能优于数据库。
 2. 数字ID天然排序，对分页或者需要排序的结果很有帮助。

缺点：

 1. 如果系统中没有Redis，还需要引入新的组件，增加系统复杂度。
 2. 需要编码和配置的工作量较大。

优化方案：

考虑到单节点的性能瓶颈，可以使用Redis集群来获取更高的吞吐量，并利用上面的方案

 - 数据库水平拆分，设置不同的初始值和相同的步长
 - 批量缓存自增ID

来配置集群。

PS：比较适合使用Redis来生成每天从0开始的流水号。比如："订单号=日期+当日自增长号"，则可以每天在Redis中生成一个key，使用INCR进行累加。

### snowflake雪花算法

核心思想：把64-bit分别划分为多段，分开来标示机器、时间、某一并发序列等，从而使每台机器及同一机器生成的ID都是互不相同。

PS：这种结构是雪花算法提出者Twitter的分法，但实际上这种算法使用可以很灵活，根据自身业务的并发情况、机器分布、使用年限等，可以自由地重新决定各部分的位数，从而增加或减少某部分的量级。比如：百度的UidGenerator、美团的Leaf等，都是基于雪花算法做一些适合自身业务的变化。

#### 雪花算法的几种不同优化方案：

##### Twitter的snowflake算法

核心思想：采用big(64bit)作为id生成类型，并将所占的64bit划分成多段。

