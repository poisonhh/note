private 类
default 包
protected 包/子类
public

**************************JVM*************************************************************
JVM 内存模型
	1 虚拟机栈
	2 本地方法栈
	3 程序计数器
	4 方法区
	5 堆
	
GC
	判断对象是否存活
		1 引用计数法(解决不了循环引用的问题)
		2 可达性分析算法
			基本思想：通过一系列称为"GC Root"的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径
				称为引用链(Reference Chain)，当一个对象到GC Roots 没有任何引用链相连(GC Roots 不可达时)，则
				证明此对象是不可用的。
			可作为GC Roots的对象包括：
				1 虚拟机栈(栈帧中的本地变量表)中引用的对象
				2 方法区中类静态属性引用的对象
				3 方法区中常量引用的对象
				4 本地方法栈中JNI(即一般说的Native方法)引用的对象
				5 活跃线程的引用对象

引用：
	引用类型		用途				被回收时间		生存时间
	强引用		对象的一般状态			从来不会		JVM停止运行时终止
	软引用		对象缓存				内存不足		内存不足时终止
	弱引用		对象缓存				垃圾回收		GC运行后终止
	虚引用		unknow					unknow			unknow
	
	强引用 > 软引用 > 弱引用 > 虚引用
	

对象的回收：
	一个对象真正被回收至少要经历两次标记过程：如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，
	那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。
	********************************************************************************************************
	当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都视为"没必要执行"。
	********************************************************************************************************
	
	如果这个对象被判定为有必要执行finalize()方法，那么这个对象会放置在一个叫做F-Queue的队列之中，并在稍后
	由一个虚拟机自动建立的、低优先级的Finalizer线程去执行它。finalize()方法是对象逃脱死亡命运的最后一次机会，
	稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果对象要在finalize()中成功拯救自己(只要重新与引用链
	上的任何一个对象建立关联即可)；如果对象这时候还没有逃脱，那基本上它就真的被回收了。
	
	****************************************************************************************************************
	任何一个对象的finalizeI()方法都只会被系统自动调用一次，如果对象面临下一次回收，它的finalize()方法不会被再次执行
	****************************************************************************************************************

回收方法区
	永久代的垃圾收集主要回收两部分内容：
		1 废弃常量
			当前系统没有其他地方引用了这个字面量
		2 无用的类
			1 该类所有的实例都已经被回收
			2 加载该类的ClassLoader已经被回收
			3 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

垃圾收集算法
	1 标记-清除算法
	2 复制算法
	3 标记-整理算法
	4 分代收集算法
java类的加载
加载-验证-准备-解析-初始化-使用-卸载

加载： 
	1 通过一个类的全限定名来获取定义此类的二进制字节流
		1.1 zip 
		1.2 从网络中获取，Applet
		1.3 运行时计算生成 (动态代理技术)
		1.4 其他文件生成，JSP
		1.5 从数据库中读取
	2 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
	3 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口

验证：
	1 文件格式验证
		该验证阶段的主要目的是保证输入的字节流能正确的解析并存储于方法区之内，只有通过了这个阶段的验证之后，
		字节流才会进入内存的方法区中进行存储，后面的验证阶段全部都是基于方法区的存储结构进行的，不会在直接操作字节流。
	2 元数据验证
		该阶段的主要目的是对类的元数据信息进行语义校验，保证不存在不符合Java语言规范的元数据信息。
	3 字节码验证
	4 符号引用验证
	
解析：
	解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。
	符号引用：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义的定位到目标即可。符号
			  引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中。
	直接引用：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局
			  相关的，用一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经
			  在内存中存在。
	解析动作的主要针对对象：
		1 类/接口 (CONSTANT_Class_info)
		2 字段 (CONSTANT_Fieldref_info)
		3 类方法 (CONSTANT_Methodref_info)
		4 接口方法 (CONSTANT_InterfaceMethodref_info)
		5 方法类型 (CONSTANT_MethodType_info)
		6 方法句柄 (CONSTANT_MethodHandle_info)
		7 调用点限定符 (CONSTANT_InvokeDynamic_info)
			  

双亲委派模型
	1 启动类加载器(Bootstrap ClassLoader)
	2 扩展类加载器(Extension ClassLoader)
	3 应用程序类加载器(Application ClassLoader)
	工作过程：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委托给父类加载器去完成，
	每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父类加载器反馈自己无法
	完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。
准备：
	准备阶段是正式为变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。
	
***********************************************************************************************************************
	
	
java 深浅拷贝的问题

深浅拷贝主要是针对对象中的引用类型来区分的

浅拷贝：对于基本数据类型是值传递，对应引用数据类型是引用传递
深拷贝：对于基本数据类型是值传递，对于引用数据类型是创建一个新对象，并复制其内容

产生死锁的四个必要条件
1 互斥条件
2 请求与保持条件
3 不剥夺条件
4 循环等待条件

CountdownLatch
CyclicBarrier

Executors
	newFiexedThreadPool
	newCachedThreadPool
	newSingleThreadPool
	newScheduledThreadPool

**************************************************************************************

分布式相关问题
1 分布式事务
2 分布式锁
3 分布式缓存
4 分布式session

CentOS 7 虚拟机上网配置

vi /etc/sysconfig/network-scripts/ifcfg-xxx
onboot=yes
bootproto=static
IPADDR=
GATEWAY=
NETMASK=
DNS=

service network restart

vi /etc/resolv.conf
nameserver 8.8.8.8

ifconfig tool 安装
yum install -y net-tools

window nginx
https://www.cnblogs.com/jiangwangxiang/p/8481661.html

启动
1 双击 nginx.exe
2 cmd 窗口切换到nginx 目录下面，nginx.exe 或者 start nginx 
关闭
1 cmd nginx -s stop 或者 nginx -s quit
2 taskkill /f /t /im nginx.exe

git
	ssh-keygen -t rsa -C "yourEmail"
	cd ~/.ssh
	cat id_rsa.pub

 


