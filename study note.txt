private 类
default 包
protected 包/子类
public

java内的加载
加载-验证-准备-解析-初始化-使用-卸载

加载： 
	1 通过一个类的全限定名来获取定义此类的二进制字节流
		1.1 zip 
		1.2 从网络中获取，Applet
		1.3 运行时计算生成 (动态代理技术)
		1.4 其他文件生成，JSP
		1.5 从数据库中读取
	2 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
	3 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口

验证：
	1 文件格式验证
		该验证阶段的主要目的是保证输入的字节流能正确的解析并存储于方法区之内，只有通过了这个阶段的验证之后，
		字节流才会进入内存的方法区中进行存储，后面的验证阶段全部都是基于方法区的存储结构进行的，不会在直接操作字节流。
	2 元数据验证
		该阶段的主要目的是对类的元数据信息进行语义校验，保证不存在不符合Java语言规范的元数据信息。
	3 字节码验证
	4 符号引用验证
	
解析：
	解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程

双亲委派模型
	1 启动类加载器(Bootstrap ClassLoader)
	2 扩展类加载器(Extension ClassLoader)
	3 应用程序类加载器(Application ClassLoader)
	工作过程：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委托给父类加载器去完成，
	每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父类加载器反馈自己无法
	完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。
准备：
	准备阶段是正式为变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。
	
破坏双亲委派模型
	
	
java 深浅拷贝的问题

深浅拷贝主要是针对对象中的引用类型来区分的

浅拷贝：对于基本数据类型是值传递，对应引用数据类型是引用传递
深拷贝：对于基本数据类型是值传递，对于引用数据类型是创建一个新对象，并复制其内容

强引用
软引用
弱引用
虚引用


产生死锁的四个必要条件
1 互斥条件
2 请求与保持条件
3 不剥夺条件
4 循环等待条件

CountdownLatch
CyclicBarrier

Executors
	newFiexedThreadPool
	newCachedThreadPool
	newSingleThreadPool
	newScheduledThreadPool


分布式相关问题
1 分布式事务
2 分布式锁
3 分布式缓存
4 分布式session

CentOS 7 虚拟机上网配置

vi /etc/sysconfig/network-scripts/ifcfg-xxx
onboot=yes
bootproto=static
IPADDR=
GATEWAY=
NETMASK=
DNS=

service network restart

vi /etc/resolv.conf
nameserver 8.8.8.8

ifconfig tool 安装
yum install -y net-tools

window nginx
https://www.cnblogs.com/jiangwangxiang/p/8481661.html

启动
1 双击 nginx.exe
2 cmd 窗口切换到nginx 目录下面，nginx.exe 或者 start nginx 
关闭
1 cmd nginx -s stop 或者 nginx -s quit
2 taskkill /f /t /im nginx.exe

test git
 


