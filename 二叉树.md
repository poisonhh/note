# 二叉树

## 二叉查找树

二叉查找树，也称有序二叉树（ordered binary tree），或已排序二叉树（sorted binary tree），是指一棵空树或者具有下列性质的二叉树：

 - 若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
 - 若任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
 - 任意节点的左、右子树也分别为二叉查找树
 - 没有键值相等的节点（no duplicate nodes）

因为一棵由n个结点随机构造的二叉查找树的高度为lgn，所以顺理成章，二叉查找树的一般操作的执行时间为O(lgn)。但二叉查找树若退化成了一棵具有n个结点的线性链后，则这些操作最坏情况运行时间为O(n)。

## 平衡二叉树（AVL树）

**平衡二叉树又称AVL树**

### 性质：

它或者是颗空树，或者是具有下列性质的二叉树：

- 它的左子树和右子树都是平衡二叉树，且左子树和右子树的深度之差的绝对值不超过1
- 若将二叉树节点的**平衡因子BF**定义为该节点的**左子树的深度减去它右子树的深度**，则平衡二叉树上所有节点的平衡因子只可能为-1，0，1
- 只要二叉树上有一个节点的**平衡因子的绝对值大于1**，那么这颗平衡二叉树就失去了平衡

### 为什么需要平衡二叉树？

当然，我们都希望所有的二叉排序树的初始序列都是平衡的，因为平衡二叉树上的任何一个结点左右字数的深度之差都不会超过1，则可以证明它的深度和logn是同数量级的，所以其平均查找长度也和logn同数量级。但是事于愿违有些二叉排序树的插入,或者初始序列由于其插入的先后顺序等缘故，将导致我们的二叉排序树的效率大大降低。

为了避免这种情况的发生，我们希望可以有一种算法，将我们的不平衡的二叉排序树转化为平衡二叉排序树。这样就可以让我们的二叉排序树结构最优化。

### 平衡二叉树的算法

- **图a** 一颗空树也算是平衡二叉树
- **图b** 只有一个**结点13**的树也算是平衡二叉树
- **图c** 在图b的基础上插入新的**结点24**之后，仍然是平衡二叉树，只是根结点的平衡因子从0变到了-1（左子树的深度为0减去右子树的深度1等于-1）
- **图d** 在图c的基础上再插入一个**结点37**，这个时候整棵树出现了不平衡现象，**根结点13**的平衡因子从-1变成了-2。我们想要让这课树平衡，而且要保证该树二叉排序树的性质，那么我们只要将**根结点13**换为**24**，**结点13**作为**结点24**的左子树，这棵树就又会回到平衡状态，如**图e**。我们把这种对树做向左逆时针“旋转”的操作称为**单向左旋平衡处理**。左旋之后，我们发现**13、24、37结点**的平衡因子都变为0。而且仍然保持着二叉排序树的特性
- **图f**当我们继续插入**结点90**之后，二叉树仍然平衡，只是24、37两个结点的平衡因子变为了-1，再次插入**53结点**之后，**结点37**的平衡因子BF由-1变为-2，这意味着该排序树中出现了新的不平衡现象，需要进行调整。但此时由于**结点53**插在**结点90**的左子树上，因此不能如上面一样作简单的调整。对于以上**结点37**为根的子树来说，既要保持二叉排序树的特性，又要平衡，则必须以**53结点**作为根结点，而使37结点成为它左子树的根，90结点称为它右子树的根。这就好比做了两次旋转，首先我们让37、53、90这棵树单先向右顺时针转变成图g，再像左逆时针变成图h，这样我们的二叉树就能够再次回到平衡状态。对于以上旋转操作我们称为**双向旋转（先右后左）平衡处理**

### 平衡算法总结

看完了上面的例子，我们总结一下二叉排序树的不平衡情况以及如何将其转化为平衡情况。
一般情况下，假设由于在二叉排序树上插入结点而失去平衡的最小子树根结点的指针为a（即a是离插入结点最近，且平衡因子绝对值不超过1的祖先结点），则失去平衡后进行调整的规律可以归纳为一下4种情况：

1. **单向右旋平衡处理：**由于在a的左子树根结点的左子树上插入结点，a的平衡因子由1增加到2，致使以a为根结点的子树失去平衡，则需要进行一次右向顺时针旋转操作。简称LL型旋转
2. **单向左旋平衡处理：**由于在a的右子树根结点的右子树上插入结点，a的平衡因子由-1增加到-2，致使以a为根结点的子树失去平衡，则需要进行一次左向逆时针旋转操作。简称RR型旋转
3. **双向旋转（先左后右）平衡处理：**由于在a的左子树的根结点的右子树上插入结点，a的平衡因子由1增加到2，致使a为根结点的子树失去平衡，则需要进行两次旋转（先左旋后右旋）操作。简称LR型旋转
4. **双向旋转（先右后左）平衡处理：**由于在a的右子树的根结点的左子树上插入结点，a的平衡因子由1增加到2，致使a为根结点的子树失去平衡，则需要进行两次旋转（先右旋后左旋）操作。简称RL型旋转

如何证明我们**插入的正确性**：中序遍历所得关键字的值序列从小到大即可（二叉排序树的性质）

### 那么如何创建一颗平衡二叉树呢?

创建平衡二叉树，我们采用依次插入节点的方式运行。而平衡二叉树上插入节点采用递归的方式进行。递归算法如下：

1. 若该树为一空树，那么插入一个数据元素为e的新节点作为平衡二叉树的根节点，树的高度增加1
2. 若待插入的数据元素e和平衡二叉树（BBST）的根节点的关键字相等，那么就不需要进行插入操作
3. 若待插入的元素e比平衡二叉树（BBST）的根节点的关键字小，而且在BBST的左子树中也不存在和e有相同关键字的节点，则将e插入在BBST的左子树上，并且当插入之后的左子树深度增加1时，分别就下列情况处理之。
   - BBST的根节点的平衡因子为-1（右子树的深度大于左子树的深度）：则将根节点的平衡因子更改为0（**左旋**），BBST的深度不变
   - BBST的根节点的平衡因子为0（左右子树的深度相等）：则将根节点的平衡因子修改为1（**不用旋**），BBST的深度增加1
   - BBST的根节点的平衡因子为1（左子树的深度大于右子树的深度）：若BBST的左子树根节点的平衡因子为1，则需要进行单向右旋转平衡处理，并且在右旋处理后，将根节点和其右子树根节点的平衡因子更改为0.树的深度不变；若BBST的左子树根节点的平衡因子为-1，则需进行**先向左，后向右的双向旋转平衡处理**，并且在旋转处理之后，修改根节点和其左，右子树根节点的平衡因子，树的深度不变；
4. 若e的关键字大于BBST的根节点的关键字，而且在BBST的右子树中不存在和e有相同关键字的节点，则将e插入到BBST的右子树上，并且当插入之后的右子树深度加1时，分别就不同的情况处理之。
   - BBST的根节点的平衡因子是1（左子树的深度大于右子树的深度）：则将根节点的平衡因子修改为0（**右旋**），BBST的深度不变；
   - BBST的根节点的平衡因子是0（左右子树的深度相等）：则将根节点的平衡因子修改为-1（**不用旋**），树的深度加1
   - BBST的根节点的平衡因子为-1（右子树的深度大于左子树的深度）：若BBST的右子树根节点的平衡因子为1，则需要进行两次选择，**第一次先向右旋转，再向左旋转处理**，并且在旋转处理之后，修改根节点和其左，右子树根节点的平衡因子，树的深度不变；若BBST的右子树根节点的平衡因子为1，则需要进行一次**单向左的旋转处理**，并且在左旋之后，更新根节点和其左，右子树根节点的平衡因子，树的深度不变；

## 红黑树

### 红黑树的介绍

先来看下算法导论对R-B Tree的介绍：
红黑树，一种二叉查找树，但在每个结点上增加一个存储位表示结点的颜色，可以是Red或Black。
通过对任何一条从根到叶子的路径上各个结点着色方式的限制，红黑树确保没有一条路径会比其他路径长出俩倍，因而是接近平衡的。

红黑树，作为一棵二叉查找树，满足二叉查找树的一般性质。下面，来了解下 二叉查找树的一般性质。

### 红黑树的5个性质

1. 每个结点要么是红的要么是黑的
2. 根结点是黑的
3. 每个叶结点（叶结点即指树尾端**NIL指针**或**NULL结点**）都是**黑的**
4. 如果一个结点是红的，那么它的两个儿子都是黑的
5. 对于任意结点而言，其到叶结点树尾端NIL指针的每条路径都包含**相同数目的黑结点**

正是红黑树的这5条性质，使一棵n个结点的红黑树始终保持了logn的高度，从而也就解释了上面所说的“红黑树的查找、插入、删除的时间复杂度最坏为O(log n)”这一结论成立的原因。