## 深入理解Java虚拟机笔记

**热点代码检测和运行时编译及优化，这使得Java应用能随着运行时间的增加而获得更高的性能。**

### JDK的组成

1. Java程序设计语言

2. Java虚拟机

3. Java API类库

   Java SE API子集和Java虚拟机这两部分统称为JRE

   JRE是支持Java程序运行的标准环境

   JDK 是支持java程序开发的最小环境

### JVM

	Classic VM  jdk1.4之后推出商业舞台
	
	Exact VM
	
	HotSpot VM

#### Sun HotSpot VM

	准确GC
	
	热点代码探测

### ORACLE

#### 	JRockit VM

#### 	HotSpot VM（BEA）

	随后oracle 公司对这两款虚拟机的整合，使之优势互补。整合方式大致上是在HotSpot的基础上，移植JRockit的优秀特性，譬如使用JRockit的垃圾回收器与MissionControl服务。
	
	其他公司的虚拟机， IBM J9 VM（IT4J）

#### 目前的高性能虚拟机

	HotSpot、JRockit、J9、Azul VM (HotSpot 基础上大量改进) BEA Liquid VM (JRockit VE)
	
	Apache Harmony VM
	
	Dalvik VM

#### 64位虚拟机

	问题:首先是内存问题，由于指针膨胀和各种数据类型对齐补白的原因，64位虚拟机的应用需要消耗更多的内存，性能比32位虚拟机差15%左右。
	
	通常采用虚拟集群的方式继续在32位的虚拟机上进行部署，但是sun公司也做出了一些改善，通过采取指针压缩，但是指针压缩会增加执行代码数量，在访问 读取 方法调用  子类型检查等操作中也受影响。



### Java内存区

#### 	程序计数器

	  程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器，此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。

#### 	Java虚拟机栈

	 线程私有的，它的生命周期与线程相同。虚拟机栈藐视的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链栈、方法出口等信息。每个方法从调用到执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。

​	通常java内存被粗略的分为 栈内存空间和堆内存空间

​	基本数据类型，对象的引用（reference类型，对象的句柄，对象内存空间的起始地址的引用指针）

	64位长度的long和double类型的数据会占用2个局部变量空间，其余的基本数据类型只占1个

#### 	本地方法栈

#### 	Java堆（Java Heap）（GC 堆）

	虚拟机所托管的内存区域最大的一块。java堆是被所有线程共享的一块区域，在虚拟机启动时创建。

​	java虚拟机规范中：所有对象的实例以及数组都要在堆上分配，但是随着JIT编译器的发展与逃逸分析技术的逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化发生，所有对象分配在堆上也渐渐变得不是那么“绝对”了。

​	Java堆是垃圾收集器管理的主要区域。从回收的角度来看，由于现在收集器都采用分带收集算法，所以Java堆还可以细分为：新生代和老年代；再细致一点的有Eden空间、From Survivor空间、To Survivor空间等。

​	内存的分配：（分配方式是由所采用的垃圾收集器是否带有压缩整理功能决定的）

​		指针碰撞：如果内存是连续的或者说是规整的，内存的分配只是指针向空闲空间移动。（Serical、ParNew 等带Compact过程的收集器）

​		空闲列表：内存空间并不是连续的，空闲内存和已使用内存相互交错，虚拟机就必须维护一个列表，每次选一个足够大的空间进行分配。（使用CMS这种基于Mark-Sweep算法的收集器）

​	内存分配在并发情况下也并不是线程安全的，其中有两种解决方案：

 	1. 对分配内存空间的动作进行同步处理--实际上虚拟机采用CAS配上失败重试的方式保证 更新操作的原子性
 	2. 按照线程分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称位本地线程分配缓冲

#### 对象的内存布局

对象在内存中的布局可以分为3个区域：对象头（Header）实例数据（Instance Data）对齐填充（Padding）