## 深入理解Java虚拟机笔记

**热点代码检测和运行时编译及优化，这使得Java应用能随着运行时间的增加而获得更高的性能。**

### JDK的组成

1. Java程序设计语言

2. Java虚拟机

3. Java API类库

   Java SE API子集和Java虚拟机这两部分统称为JRE

   JRE是支持Java程序运行的标准环境

   JDK 是支持java程序开发的最小环境

### JVM

	Classic VM  jdk1.4之后推出商业舞台
	
	Exact VM
	
	HotSpot VM

#### Sun HotSpot VM

	准确GC
	
	热点代码探测

### ORACLE

#### 	JRockit VM

#### 	HotSpot VM（BEA）

	随后oracle 公司对这两款虚拟机的整合，使之优势互补。整合方式大致上是在HotSpot的基础上，移植JRockit的优秀特性，譬如使用JRockit的垃圾回收器与MissionControl服务。
	
	其他公司的虚拟机， IBM J9 VM（IT4J）

#### 目前的高性能虚拟机

	HotSpot、JRockit、J9、Azul VM (HotSpot 基础上大量改进) BEA Liquid VM (JRockit VE)
	
	Apache Harmony VM
	
	Dalvik VM

#### 64位虚拟机

	问题:首先是内存问题，由于指针膨胀和各种数据类型对齐补白的原因，64位虚拟机的应用需要消耗更多的内存，性能比32位虚拟机差15%左右。
	
	通常采用虚拟集群的方式继续在32位的虚拟机上进行部署，但是sun公司也做出了一些改善，通过采取指针压缩，但是指针压缩会增加执行代码数量，在访问 读取 方法调用  子类型检查等操作中也受影响。



### Java内存区

#### 	程序计数器

	  程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器，此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。

#### 	Java虚拟机栈

	 线程私有的，它的生命周期与线程相同。虚拟机栈藐视的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链栈、方法出口等信息。每个方法从调用到执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。
	
	通常java内存被粗略的分为 栈内存空间和堆内存空间
	
	基本数据类型，对象的引用（reference类型，对象的句柄，对象内存空间的起始地址的引用指针）
	
	64位长度的long和double类型的数据会占用2个局部变量空间，其余的基本数据类型只占1个

#### 	本地方法栈

#### 	Java堆（Java Heap）（GC 堆）

	虚拟机所托管的内存区域最大的一块。java堆是被所有线程共享的一块区域，在虚拟机启动时创建。
	
	java虚拟机规范中：所有对象的实例以及数组都要在堆上分配，但是随着JIT编译器的发展与逃逸分析技术的逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化发生，所有对象分配在堆上也渐渐变得不是那么“绝对”了。
	
	Java堆是垃圾收集器管理的主要区域。从回收的角度来看，由于现在收集器都采用分带收集算法，所以Java堆还可以细分为：新生代和老年代；再细致一点的有Eden空间、From Survivor空间、To Survivor空间等。
	
	内存的分配：（分配方式是由所采用的垃圾收集器是否带有压缩整理功能决定的）
	
		指针碰撞：如果内存是连续的或者说是规整的，内存的分配只是指针向空闲空间移动。（Serical、ParNew 等带Compact过程的收集器）
	
		空闲列表：内存空间并不是连续的，空闲内存和已使用内存相互交错，虚拟机就必须维护一个列表，每次选一个足够大的空间进行分配。（使用CMS这种基于Mark-Sweep算法的收集器）
	
	内存分配在并发情况下也并不是线程安全的，其中有两种解决方案：

 	1. 对分配内存空间的动作进行同步处理--实际上虚拟机采用CAS配上失败重试的方式保证 更新操作的原子性
 	2. 按照线程分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称位本地线程分配缓冲

#### 对象的内存布局

对象在内存中的布局可以分为3个区域：对象头（Header）实例数据（Instance Data）对齐填充（Padding）

内存泄漏：查看泄露对象到GC Root的引用链

内存溢出：检查虚拟机的堆参数，与物理机对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长，持有状态时间过长的情况，尝试减少程序运行期的内存消耗。

### 垃圾回收

#### 引用计数算法

通过计数器的值判断对象是否在使用，无法解决对象之间相互循环引用的问题，HotSpot并没有使用这种方式

#### 可达性分析算法

GC Roots,通过一系列的称为 GC Roots的对象作为起点，从这些节点开始向下搜索，搜索走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，也就是从GC Roots 到这个对象不可达时，则证明这个对象是不可用的。

可作为GC Roots的对象包括：

​	虚拟机栈（栈帧中的本地变量表）中引用的对象

​	方法区中类静态属性引用的对象

​	方法区中常量引用的对象

​	本地方法栈中JNI（即一般说的Natice 方法）引用的对象

#### 引用

强引用、软引用、弱引用、虚引用

#### 垃圾收集算法

##### 标记-清除算法

首先标记出所有需要回收的对象，在 标记完成后统一回收所有被标记的对象。

不足之处：

效率问题，标记和清除两个过程效率都不高

空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后程序在运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次的垃圾收集动作。

##### 复制算法

将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当一块内存用完了，就将还存活着的对象复制到另一块上面，然后再把已使用过的内存空间一次清理掉。这种方式在内存分配时就i不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效，只是这种算法的代价时将内存缩为原来的一半，代价太高。

但是一般虚拟机都是按照8（Eden）：1(Survivor):1（Survivor）

当回收时，将Eden和其中一块Survivor中还存活的对象一次性复制到另一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间，当空闲Survivor空间不足以一次性存储这些存活的对象时，需要依赖其他内存进行分配担保（一般指的是老年代）。

#### 标记-整理算法

先标记要清理的对象，然后让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。

#### 分代收集算法

按照对象的存活周期不同将内存划分为几块，一般是把java堆分为新生代和老年代

新生代：复制算法

老年代：标记-清除、标记-整理